import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import os
import warnings
import itertools
import time
from PIL import Image

warnings.filterwarnings("ignore")

# Imports dos m√≥dulos customizados
from constants import (
    FINAL_CAPITAL_LABEL, TOTAL_RETURN_LABEL, METRIC_LABEL,
    PETR4_SYMBOL, LOADING_PC1_LABEL, LOADING_PC2_LABEL,
    WEIGHT_PERCENTAGE_LABEL, MT5_REAL_LABEL, PCA_PORTFOLIO_LABEL,
    TELECOMMUNICATIONS_SECTOR, MATERIALS_SECTOR, TECHNOLOGY_SECTOR,
    MAX_DRAWDOWN_LABEL, ANNUAL_RETURN_LABEL, SHARPE_RATIO_LABEL,
    RESULTS_INTERPRETATION_LABEL, CORRELATION_LABEL,
    PCA_PERFORMANCE_TITLE, MT5_COMPARISON_TITLE, ADVANCED_PCA_TITLE, 
    PAIR_TRADING_TITLE, STATISTICAL_ANALYSIS_TITLE, NORMALITY_ANALYSIS_TITLE,
    DATA_NOT_FOUND_MSG, SELECT_VALID_PAIR_MSG,
    get_raw_data_path, DATA_DIR, RAW_DATA_FILENAME,
    SYMBOL_COLUMN, PL_ABS_COLUMN, LOSS_LABEL, PROFIT_LABEL
)
from mt5_parser import MT5ReportParser
from trading_report_parser import TradingReportParser  # Novo parser
from pca_advanced import PCAAdvancedAnalysis
from pair_trading import PairTradingAnalysis
from portfolio_allocation import PortfolioAllocationManager
from statistical_analysis import StatisticalAnalysis
from pair_trading_advanced import PairTradingAdvanced
from trading_report_parser import TradingReportParser
from mt5_comparison_helpers import (
    validate_mt5_data, validate_pca_data, setup_mt5_comparison_sidebar,
    select_pca_assets, calculate_pca_metrics, display_pca_summary,
    display_mt5_summary, display_comparative_analysis, display_recommendations,
    plot_comparative_performance, analyze_symbol_performance, create_risk_metrics_radar
)
from data_fetch import ASSET_CATEGORIES
from financial_formatting import (
    format_percentage, format_currency, format_ratio, 
    auto_format_metric, FINANCIAL_METRICS_FORMAT
)
from app_helpers import (
    plot_temporal_comparison, plot_drawdown_comparison,
    create_risk_metrics_analysis, create_performance_radar_chart,
    create_portfolio_allocation_analysis
)
from pdf_export_helpers import create_download_button, generate_complete_statistical_analysis_pdf

# =====================================================================
# CONFIGURA√á√ÉO DA P√ÅGINA
# =====================================================================

st.set_page_config(
    page_title="üí∞ An√°lise Bilion√°rio",
    page_icon="üí∞",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# =====================================================================
# FUN√á√ïES AUXILIARES
# =====================================================================

def calculate_metrics(returns, initial_capital):
    """Calcula m√©tricas de performance do portfolio"""
    if len(returns) == 0:
        return {
            'total_return': 0.0,
            'annual_return': 0.0,
            'monthly_return': 0.0,
            'annual_volatility': 0.0,
            'max_drawdown': 0.0
        }
    
    equity_curve = (1 + returns).cumprod() * initial_capital
    total_return = (equity_curve.iloc[-1] / initial_capital) - 1
    
    n_periods = len(returns)
    if n_periods > 0:
        annual_return = (1 + total_return) ** (252 / n_periods) - 1
        # Calcular retorno mensal m√©dio
        monthly_return = (1 + total_return) ** (21 / n_periods) - 1 if n_periods >= 21 else annual_return / 12
    else:
        annual_return = 0.0
        monthly_return = 0.0
    
    annual_volatility = returns.std() * np.sqrt(252) if len(returns) > 1 else 0.0
    
    running_max = equity_curve.expanding().max()
    drawdown = (equity_curve / running_max - 1)
    max_drawdown = drawdown.min() if len(drawdown) > 0 else 0.0
    
    return {
        'total_return': total_return,
        'annual_return': annual_return,
        'monthly_return': monthly_return,
        'annual_volatility': annual_volatility,
        'max_drawdown': max_drawdown
    }

def get_monthly_returns(returns):
    """Calcula retornos mensais"""
    monthly = returns.resample('M').apply(lambda x: (1 + x).prod() - 1)
    return monthly

def load_mt5_data():
    """Carrega dados MT5 do sidebar"""
    uploaded_mt5 = st.sidebar.file_uploader(
        "üìä Upload relat√≥rio MT5 (HTML)",        type=['html', 'htm'],
        help="Fa√ßa upload do relat√≥rio HTML exportado do MetaTrader 5"
    )

    mt5_data = None
    if uploaded_mt5 is not None:
        try:
            file_type = '.html' if uploaded_mt5.name.lower().endswith(('.html', '.htm')) else '.pdf'
            parser = MT5ReportParser(uploaded_mt5, file_type)
            mt5_data = parser.get_portfolio_summary()
            
            # Verifica√ß√£o robusta de que mt5_data √© v√°lido
            if mt5_data and isinstance(mt5_data, dict):
                st.sidebar.success("‚úÖ MT5 carregado com sucesso!")
                st.sidebar.write(f"**Conta:** {mt5_data.get('account_name', 'N/A')}")
                st.sidebar.write(f"**Saldo:** R$ {mt5_data.get('balance', 0):,.2f}")
                st.sidebar.write(f"**Lucro:** R$ {mt5_data.get('net_profit', 0):,.2f}")
                st.sidebar.write(f"**Retorno:** {mt5_data.get('gain', '0%')}")
            else:
                st.sidebar.warning("‚ö†Ô∏è Arquivo MT5 processado, mas dados insuficientes extra√≠dos.")
                # Criar dados padr√£o se mt5_data for None
                mt5_data = {
                    'account_name': 'Conta MT5', 'account_number': 'N/A', 'currency': 'BRL',
                    'balance': 0, 'equity': 0, 'net_profit': 0, 'initial_capital': 0,
                    'gain': '0%', 'drawdown': '0%', 'trading_activity': '0%'
                }
            
        except Exception as e:
            st.sidebar.error(f"‚ùå Erro ao processar MT5: {str(e)}")
            mt5_data = None
    
    return mt5_data

# Fun√ß√µes auxiliares para reduzir complexidade cognitiva

def _validate_mt5_data():
    """Valida se h√° dados MT5 carregados"""
    mt5_data = st.session_state.get('mt5_data')
    
    if not mt5_data:
        st.warning("‚ö†Ô∏è Nenhum dado MT5 carregado. Fa√ßa upload de um relat√≥rio MT5 no sidebar.")
        st.info("üìù **Como usar:** Carregue um relat√≥rio MT5 HTML no sidebar para ativar as compara√ß√µes avan√ßadas.")
        return None
        
    st.success("‚úÖ Dados MT5 carregados com sucesso!")
    return mt5_data

def _validate_pca_data():
    """Valida e carrega dados PCA"""
    RAW_DATA = get_raw_data_path()
    
    if not os.path.exists(RAW_DATA):
        st.error("‚ùå Dados PCA n√£o encontrados. V√° para a p√°gina Home e baixe os dados primeiro.")
        return None, None
    
    df = pd.read_csv(RAW_DATA, index_col=0, parse_dates=True)
    returns = df.pct_change().dropna()
    return df, returns

def _setup_mt5_comparison_sidebar():
    """Configura sidebar para compara√ß√£o MT5"""
    st.sidebar.subheader("‚öôÔ∏è Configura√ß√µes de Compara√ß√£o")
    
    initial_capital = st.sidebar.number_input(
        'üí∞ Capital Base (R$)',
        min_value=100.0, 
        max_value=1e7, 
        value=10000.0, 
        step=100.0
    )
    
    show_detailed_metrics = st.sidebar.checkbox("üìä M√©tricas Detalhadas", value=True)
    
    return initial_capital, show_detailed_metrics

def _select_pca_assets(df):
    """Seleciona ativos para compara√ß√£o PCA"""
    if 'selected' not in st.session_state:
        st.session_state['selected'] = df.columns.tolist()[:5]
    
    selected = st.sidebar.multiselect(
        'Ativos PCA para compara√ß√£o', 
        df.columns.tolist(),
        default=st.session_state['selected'][:5]
    )
    
    if len(selected) < 3:
        st.warning('‚ö†Ô∏è Selecione pelo menos 3 ativos para compara√ß√£o v√°lida')
        return None
    
    return selected

def _calculate_pca_metrics(returns, selected, initial_capital):
    """Calcula m√©tricas do portfolio PCA"""
    returns_selected = returns[selected]
    portf_ret = returns_selected.mean(axis=1)
    portf_cum = (1 + portf_ret).cumprod() * initial_capital
    pca_metrics = calculate_metrics(portf_ret, initial_capital)
    
    return portf_ret, portf_cum, pca_metrics

def _display_pca_summary(pca_metrics, portf_cum, initial_capital):
    """Exibe resumo do portfolio PCA"""
    pca_final_value = portf_cum.iloc[-1]
    pca_return = (pca_final_value / initial_capital) - 1
    
    st.metric(FINAL_CAPITAL_LABEL, format_currency(pca_final_value))
    st.metric(TOTAL_RETURN_LABEL, format_percentage(pca_return))
    st.metric("Retorno Anualizado", format_percentage(pca_metrics['annual_return']))
    st.metric("Retorno Mensal", format_percentage(pca_metrics.get('monthly_return', pca_metrics['annual_return'] / 12)))
    st.metric("Volatilidade", format_percentage(pca_metrics['annual_volatility']))
    st.metric("Max Drawdown", format_percentage(pca_metrics['max_drawdown']))
    
    return pca_return

def _display_mt5_summary(mt5_data):
    """Exibe resumo do MT5"""
    mt5_balance = mt5_data.get('balance', 0)
    mt5_profit = mt5_data.get('net_profit', 0)
    mt5_initial = mt5_data.get('initial_capital', mt5_balance - mt5_profit)
    mt5_return = mt5_profit / mt5_initial if mt5_initial > 0 else 0
    
    st.metric("Saldo Atual", format_currency(mt5_balance))
    st.metric("Lucro L√≠quido", format_currency(mt5_profit))
    st.metric(TOTAL_RETURN_LABEL, format_percentage(mt5_return))
    
    return mt5_return

def _display_comparative_analysis(pca_metrics, pca_return, mt5_return):
    """Exibe an√°lise comparativa detalhada"""
    st.subheader("üîç An√°lise Comparativa Detalhada")
    
    # Performance comparison
    col1, col2 = st.columns(2)
    with col1:
        if pca_return > mt5_return:
            st.success(f"‚úÖ **PCA venceu**: +{(pca_return - mt5_return):.2%} de diferen√ßa")
        else:
            st.error(f"‚ùå **MT5 venceu**: +{(mt5_return - pca_return):.2%} de diferen√ßa")
    
    # Risk-adjusted returns
    risk_adjusted_pca = pca_metrics['annual_return'] / pca_metrics['annual_volatility'] if pca_metrics['annual_volatility'] > 0 else 0
    risk_adjusted_mt5 = mt5_return / 0.15  # Assumindo volatilidade de 15% para MT5
    
    with col2:
        if risk_adjusted_pca > risk_adjusted_mt5:
            st.success("‚úÖ **PCA**: Melhor retorno ajustado ao risco")
        else:
            st.info("üìä **MT5**: Melhor retorno ajustado ao risco")

def _display_recommendations(pca_metrics, mt5_return, pca_return):
    """Exibe recomenda√ß√µes baseadas na an√°lise"""
    st.markdown("### üí° Recomenda√ß√µes")
    recommendations = []
    
    if pca_metrics['annual_volatility'] > 0.3:
        recommendations.append("‚ö†Ô∏è Considere reduzir a volatilidade do portfolio PCA")
    
    if abs(pca_metrics['max_drawdown']) > 0.2:
        recommendations.append("üìâ Implemente estrat√©gias de controle de drawdown")
    
    if pca_return < mt5_return:
        recommendations.append("üìà Analise os ativos MT5 para melhorar sele√ß√£o PCA")
    
    recommendations.append("üîÑ Continue monitorando ambas as estrat√©gias")
    
    for rec in recommendations:
        st.write(f"- {rec}")

# =====================================================================
# P√ÅGINAS DA APLICA√á√ÉO
# =====================================================================

def show_home_page():
    """P√°gina inicial"""
    # Logo
    try:
        logo = Image.open('logo.png')
        st.image(logo, width=150)
    except FileNotFoundError:
        st.write("üöÄ **An√°lise de Portf√≥lio - by KG**")

    st.title("üöÄ Bilion√°rio - An√°lise de Portfolio com PCA")
    st.markdown('Bem-vindo! Ferramenta de an√°lise de carteiras.')
    st.markdown('[Acesse online ‚ñ∂Ô∏è](https://bilionario-3w62sdcxhsf3i8yfqywoaq.streamlit.app/)')

  

    # Informa√ß√µes sobre a aplica√ß√£o
    st.markdown("---")
    st.subheader("‚ÑπÔ∏è Sobre a Aplica√ß√£o")
    
    col1, col2 = st.columns(2)
    with col1:
        st.markdown("""
        **üéØ Funcionalidades:**
        - An√°lise PCA de portfolios
        - Compara√ß√£o com dados MT5
        - Gest√£o por setores
        - An√°lise avan√ßada PCA
        - Pair Trading
        """)
    
    with col2:
        st.markdown("""
        **üìä M√©tricas Calculadas:**
        - Retorno Total e Anualizado
        - Volatilidade
        - Sharpe Ratio
        - Max Drawdown
        - √çndices de risco
        """)
    
    # Agradecimentos especiais
    st.markdown("---")
    st.subheader("‚ù§Ô∏è Agradecimentos Especiais")
    st.markdown("""
    **Agradecimentos sinceros a:**
    
    üë®‚Äçüíª **Brenda Souza Barros & Felipe Freitas Alves** pela incr√≠vel cumplicidade e apoio cont√≠nuo
    no desenvolvimento deste projeto. A parceria de voc√™s foi fundamental para a cria√ß√£o desta ferramenta.
    """)
    # Download de dados
    st.markdown("---")
    st.subheader("üì• Dados dos Ativos")
    
    if st.button('üîÑ Baixar/Atualizar dados dos ativos'):
        with st.spinner('Baixando dados...'):
            from data_fetch import fetch_data
            fetch_data()
        st.success('‚úÖ Dados baixados com sucesso!')    # Status dos dados
    RAW_DATA = get_raw_data_path()
    
    if os.path.exists(RAW_DATA):
        df = pd.read_csv(RAW_DATA, index_col=0, parse_dates=True)
        st.success(f"üìä Dados dispon√≠veis: {len(df.columns)} ativos, {len(df)} dias")
        
        # Preview dos dados
        with st.expander("üëÅÔ∏è Preview dos Dados"):
            st.dataframe(df.tail(10), use_container_width=True)
            
        # Estat√≠sticas b√°sicas
        with st.expander("üìà Estat√≠sticas B√°sicas"):
            returns = df.pct_change().dropna()
            stats = pd.DataFrame({
                'Retorno M√©dio (%)': (returns.mean() * 100).round(3),
                'Volatilidade (%)': (returns.std() * 100).round(3),
                'Sharpe (aprox)': (returns.mean() / returns.std()).round(3)
            })
            st.dataframe(stats, use_container_width=True)
    else:
        st.warning("‚ö†Ô∏è Dados n√£o encontrados. Clique no bot√£o acima para baixar os dados.")

def show_pca_performance_page():
    """P√°gina de an√°lise PCA"""
    st.title(PCA_PERFORMANCE_TITLE)
    
    RAW_DATA = get_raw_data_path()
    
    if not os.path.exists(RAW_DATA):
        st.error(DATA_NOT_FOUND_MSG)
        return
    
    df = pd.read_csv(RAW_DATA, index_col=0, parse_dates=True)
    returns = df.pct_change().dropna()
    
    # Sele√ß√£o de ativos
    st.sidebar.subheader("üéØ Sele√ß√£o de Ativos")
    
    if 'selected' not in st.session_state:
        st.session_state['selected'] = df.columns.tolist()[:5]
    
    # Auto-sele√ß√£o
    if st.sidebar.button('üé≤ Auto-sele√ß√£o'):
        monthly = get_monthly_returns(returns)
        best, combo = -1, None
        for k in range(3, min(10, len(df.columns)) + 1):
            for c in itertools.combinations(df.columns, k):
                avg = monthly[list(c)].mean(axis=1).mean()
                if avg > best: 
                    best, combo = avg, c
        st.session_state['selected'] = list(combo)
        st.sidebar.success(f"‚úÖ Selecionados: {len(combo)} ativos")
        
    selected = st.sidebar.multiselect(
        'Selecione ativos (3-20)', 
        df.columns.tolist(),
        default=st.session_state['selected']    )
    
    if not 3 <= len(selected) <= 20:
        st.warning('‚ö†Ô∏è Selecione entre 3 e 20 ativos para an√°lise PCA')
        return
        
    returns_selected = returns[selected]
    
    # Par√¢metros
    initial_capital = st.sidebar.number_input(
        'üí∞ Capital Inicial (R$)', 
        min_value=100.0, 
        max_value=1e7, 
        value=10000.0, 
        step=100.0
    )
    
    # C√°lculo da performance
    if returns_selected.empty:
        st.warning("‚ö†Ô∏è N√£o h√° dados suficientes para an√°lise.")
        return
    
    portf_ret = returns_selected.mean(axis=1)
    portf_cum = (1 + portf_ret).cumprod() * initial_capital
    metrics = calculate_metrics(portf_ret, initial_capital)    # M√©tricas principais
    st.subheader("üìä M√©tricas de Performance")
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        st.metric(TOTAL_RETURN_LABEL, format_percentage(metrics['total_return']))
    with col2:
        st.metric("Retorno Anualizado", format_percentage(metrics['annual_return']))
    with col3:
        st.metric("Retorno Mensal", format_percentage(metrics['monthly_return']))
    with col4:
        st.metric("Volatilidade", format_percentage(metrics['annual_volatility']))
    with col5:
        st.metric(MAX_DRAWDOWN_LABEL, format_percentage(metrics['max_drawdown']))
    
    # Gr√°fico de evolu√ß√£o
    st.subheader("üìà Evolu√ß√£o do Portfolio")
    fig_evolution = px.line(
        x=portf_cum.index, 
        y=portf_cum.values,
        title='Evolu√ß√£o do Capital',
        labels={'x': 'Data', 'y': 'Capital (R$)'}
    )
    st.plotly_chart(fig_evolution, use_container_width=True)
    
    # An√°lise PCA
    st.subheader("üîç An√°lise PCA")
    
    n_components = st.sidebar.slider(
        'N√∫mero de Componentes PCA', 
        min_value=1, 
        max_value=len(selected), 
        value=min(5, len(selected))
    )
    
    # Aplicar PCA
    scaler = StandardScaler()
    scaled_data = scaler.fit_transform(returns_selected.fillna(0))
    pca = PCA(n_components=n_components, random_state=42)
    components = pca.fit_transform(scaled_data)
    
    # Vari√¢ncia explicada
    explained_var = pca.explained_variance_ratio_
    fig_scree = px.bar(
        x=list(range(1, len(explained_var) + 1)), 
        y=explained_var * 100,
        title='Scree Plot - Vari√¢ncia Explicada por Componente',
        labels={'x': 'Componente', 'y': 'Vari√¢ncia Explicada (%)'}
    )
    st.plotly_chart(fig_scree, use_container_width=True)
    
    # Scatter plot dos primeiros 2 componentes
    if n_components >= 2:
        fig_scatter = px.scatter(
            x=components[:, 0], 
            y=components[:, 1],
            title='Primeiros 2 Componentes Principais',
            labels={'x': 'PC1', 'y': 'PC2'}
        )
        st.plotly_chart(fig_scatter, use_container_width=True)
    
    # Retornos mensais
    st.subheader("üìÖ Retornos Mensais")
    monthly_returns = get_monthly_returns(portf_ret)
    fig_monthly = px.bar(
        x=monthly_returns.index, 
        y=monthly_returns.values,
        title='Retornos Mensais do Portfolio'
    )
    st.plotly_chart(fig_monthly, use_container_width=True)

def show_mt5_comparison_page():
    """P√°gina de compara√ß√£o avan√ßada com MT5"""
    st.title("‚öñÔ∏è Compara√ß√£o Avan√ßada PCA vs MT5")
    
    # Validar dados MT5
    mt5_data = validate_mt5_data()
    if mt5_data is None:
        return
    
    # Validar e carregar dados PCA
    df, returns = validate_pca_data()
    if df is None or returns is None:
        return
    
    # Configura√ß√µes da sidebar
    initial_capital, show_detailed_metrics = setup_mt5_comparison_sidebar()
    
    # Sele√ß√£o de ativos para PCA
    selected = select_pca_assets(df)
    if selected is None:
        return
      # C√°lculo das m√©tricas do portfolio PCA
    _, portf_cum, pca_metrics = calculate_pca_metrics(returns, selected, initial_capital)
      # === RESUMO COMPARATIVO ===
    st.subheader("üìä Resumo Comparativo")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("### ü§ñ Portfolio PCA")
        pca_return = display_pca_summary(pca_metrics, portf_cum, initial_capital)
    
    with col2:
        st.markdown("### üìà MT5 Real")
        mt5_return = display_mt5_summary(mt5_data)
    
    # Gr√°fico de performance comparativa
    plot_comparative_performance(portf_cum, mt5_data, initial_capital)
    
    # An√°lise por s√≠mbolo MT5
    analyze_symbol_performance(mt5_data)
    
    # Gr√°fico de radar para m√©tricas de risco
    create_risk_metrics_radar(pca_metrics, mt5_data)
    
    # An√°lise comparativa detalhada
    if show_detailed_metrics:
        display_comparative_analysis(pca_metrics, pca_return, mt5_return)
    
    # Recomenda√ß√µes
    display_recommendations(pca_metrics, mt5_return, pca_return)

def show_sector_management_page():
    """P√°gina avan√ßada de gest√£o por setor"""
    from sector_management_helpers import (
        get_risk_profile_config, display_risk_profile, configure_sector_allocation,
        display_allocation_status, create_allocation_visualizations, analyze_sector_performance,
        display_performance_results, generate_recommendations, save_configuration, export_to_excel
    )
    
    st.title("üí∞ Gest√£o Avan√ßada por Setor")
    
    RAW_DATA = get_raw_data_path()
    
    if not os.path.exists(RAW_DATA):
        st.error(DATA_NOT_FOUND_MSG)
        return
    
    df = pd.read_csv(RAW_DATA, index_col=0, parse_dates=True)
    returns = df.pct_change().dropna()
    
    st.markdown("""
    üí° **Gest√£o por Setor**: Aloque seu capital de forma inteligente entre diferentes setores da economia,
    otimizando risco e retorno atrav√©s de diversifica√ß√£o setorial.
    """)
    
    # Par√¢metros principais
    st.sidebar.subheader("‚öôÔ∏è Configura√ß√µes")
    total_capital = st.sidebar.number_input(
        'üí∞ Capital Total (R$)', 
        min_value=1000.0, 
        max_value=1e8, 
        value=100000.0, 
        step=1000.0
    )
    
    rebalance_frequency = st.sidebar.selectbox(
        "üîÑ Frequ√™ncia de Rebalanceamento",
        ["Mensal", "Trimestral", "Semestral", "Anual"]
    )
    
    risk_tolerance = st.sidebar.slider(
        "üìä Toler√¢ncia ao Risco",
        min_value=1,
        max_value=10,
        value=5,
        help="1=Conservador, 10=Agressivo"
    )
    
    # === CONFIGURA√á√ÉO DE ALOCA√á√ÉO POR SETOR ===
    st.subheader("üè≠ Configura√ß√£o de Aloca√ß√£o por Setor")
    
    # Obter configura√ß√£o de perfil de risco
    available_sectors = list(ASSET_CATEGORIES.keys())
    risk_config = get_risk_profile_config(risk_tolerance)
    suggested_allocation = risk_config['suggested_allocation']
    risk_profile = risk_config['profile']
    profile_color = risk_config['color']
    
    # Exibir perfil de risco
    display_risk_profile(profile_color, risk_profile)
    
    # Interface para configurar aloca√ß√£o
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader("‚öñÔ∏è Aloca√ß√£o Manual")
        sector_allocations, total_allocation = configure_sector_allocation(
            available_sectors, suggested_allocation
        )
    
    with col2:
        st.subheader("üìä Status da Aloca√ß√£o")
        display_allocation_status(total_allocation, total_capital, sector_allocations)
    
    # === VISUALIZA√á√ÉO DA ALOCA√á√ÉO ===
    if total_allocation > 0:
        st.subheader("üìà Visualiza√ß√£o da Aloca√ß√£o")
        create_allocation_visualizations(sector_allocations, available_sectors, suggested_allocation)
    
    # === AN√ÅLISE DE PERFORMANCE POR SETOR ===
    if total_allocation == 100:
        st.markdown("---")
        st.subheader("üìä An√°lise de Performance por Setor")
        
        allocation_manager, selected_assets, portfolio_weights = analyze_sector_performance(
            df, returns, sector_allocations
        )
        
        if allocation_manager and selected_assets and portfolio_weights:
            display_performance_results(allocation_manager, selected_assets, portfolio_weights)
    
    # === RECOMENDA√á√ïES E INSIGHTS ===
    st.markdown("---")
    st.subheader("üí° Recomenda√ß√µes Personalizadas")
    
    recommendations = generate_recommendations(risk_tolerance, sector_allocations, rebalance_frequency)
    for rec in recommendations:
        st.write(f"‚Ä¢ {rec}")
    
    # === EXPORT E SALVAMENTO ===
    st.markdown("---")
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üíæ Salvar Configura√ß√£o"):
            save_configuration(sector_allocations, total_capital, risk_tolerance, rebalance_frequency)
    
    with col2:
        if st.button("üì• Exportar para Excel"):
            export_to_excel(total_allocation, sector_allocations, total_capital, risk_profile, rebalance_frequency)

def show_advanced_pca_page():
    """P√°gina de PCA avan√ßado"""    
    from advanced_pca_simplificado import (
        setup_pca_sidebar, execute_static_pca_analysis, display_pca_loadings,
        execute_rolling_pca_analysis, display_rolling_pca_stability, build_pca_portfolio,
        display_portfolio_results, analyze_pca_risk, display_interactive_pca_example
    )
    
    st.title(ADVANCED_PCA_TITLE)
    
    RAW_DATA = get_raw_data_path()
    
    if not os.path.exists(RAW_DATA):
        st.error(DATA_NOT_FOUND_MSG)
        return
    
    try:
        df = pd.read_csv(RAW_DATA, index_col=0, parse_dates=True)
        returns = df.pct_change().dropna()
        
        # Header com informa√ß√µes did√°ticas
        st.markdown("""
        ### üß† An√°lise PCA Avan√ßada
        
        **An√°lise de Componentes Principais (PCA)** √© uma t√©cnica estat√≠stica que reduz a dimensionalidade dos dados 
        identificando as dire√ß√µes de maior vari√¢ncia. Na an√°lise de portfolios:
        
        - **Componentes principais**: Combina√ß√µes lineares dos ativos originais
        - **Vari√¢ncia explicada**: Quanto cada componente captura da varia√ß√£o total
        - **Loadings**: Peso de cada ativo em cada componente
        - **PCA rolling**: Evolu√ß√£o temporal dos componentes
        """)
        
        # Tabs para organizar an√°lises
        pca_tabs = st.tabs([
            "üìä An√°lise Est√°tica", 
            "üìà PCA Rolling", 
            "üéØ Sele√ß√£o de Portfolio", 
            "üìâ An√°lise de Risco",
            "üî¨ Explica√ß√£o Did√°tica"
        ])
        
        # Configura√ß√£o no sidebar
        sidebar_config = setup_pca_sidebar(df)
        if sidebar_config[0] is None:
            st.warning("‚ö†Ô∏è Selecione pelo menos 3 ativos para an√°lise PCA")
            return
        
        selected_assets, n_components, rebalance_freq, window_size, rebalance_window = sidebar_config
        returns_selected = returns[selected_assets]
        
        # Tab 1: An√°lise Est√°tica
        with pca_tabs[0]:
            st.subheader("üìä An√°lise PCA Est√°tica")
            pca, components, explained_var = execute_static_pca_analysis(
                returns_selected, selected_assets, n_components
            )
            display_pca_loadings(pca, selected_assets, explained_var)
        
        # Tab 2: PCA Rolling
        with pca_tabs[1]:
            rolling_variance, rolling_loadings_pc1, rolling_dates = execute_rolling_pca_analysis(
                returns_selected, selected_assets, window_size, rebalance_freq, rebalance_window
            )
            display_rolling_pca_stability(rolling_variance, rolling_loadings_pc1, rolling_dates, selected_assets)
        
        # Tab 3: Sele√ß√£o de Portfolio
        with pca_tabs[2]:
            strategy_type = st.selectbox(
                "Estrat√©gia de constru√ß√£o:",
                ["Maximum Diversification", "Minimum Variance", "Equal Risk Contribution"]
            )
            
            portfolio_results = build_pca_portfolio(
                pca, components, returns_selected, selected_assets, strategy_type, rebalance_freq
            )
            
            if portfolio_results[0] is not None:
                weights, portfolio_cumulative, total_return, annual_return, annual_vol, sharpe = portfolio_results
                display_portfolio_results(
                    weights, portfolio_cumulative, total_return, annual_return, 
                    annual_vol, sharpe, selected_assets, strategy_type
                )
        
        # Tab 4: An√°lise de Risco
        with pca_tabs[3]:
            analyze_pca_risk(pca, selected_assets, n_components)
        
        # Tab 5: Explica√ß√£o Did√°tica
        with pca_tabs[4]:
            display_interactive_pca_example(pca, selected_assets, n_components)
                
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar dados: {str(e)}")

def show_pair_trading_page():
    """P√°gina de pair trading"""
    st.title(PAIR_TRADING_TITLE)
    
    RAW_DATA = get_raw_data_path()
    
    if not os.path.exists(RAW_DATA):
        st.error(DATA_NOT_FOUND_MSG)
        return
    
    try:
        df = pd.read_csv(RAW_DATA, index_col=0, parse_dates=True)
        
        # Header com informa√ß√µes did√°ticas
        st.markdown("""
        ### üë´ Estrat√©gia de Pair Trading
        
        **Pair Trading** √© uma estrat√©gia market-neutral que busca lucrar com a converg√™ncia de pre√ßos entre ativos correlacionados:
        
        - **Cointegra√ß√£o**: Rela√ß√£o de longo prazo entre ativos
        - **Spread**: Diferen√ßa de pre√ßos normalizada entre os ativos
        - **Z-Score**: Desvio do spread em rela√ß√£o √† m√©dia hist√≥rica
        - **Mean Reversion**: Tend√™ncia do spread retornar √† m√©dia
        """)
        
        # Tabs principais
        pair_tabs = st.tabs([
            "üîç Identificar Pares", 
            "üìä An√°lise Detalhada", 
            "‚ö° Sinais de Trading", 
            "üìà Backtest", 
            "üéØ Otimiza√ß√£o",
            "üìö Tutorial"
        ])
        
        # Configura√ß√µes na sidebar usando helper
        from pair_trading_helpers import setup_pair_trading_sidebar
        params = setup_pair_trading_sidebar()
        # Inicializar an√°lise
        pair_analyzer = PairTradingAnalysis(df)
        all_assets = df.columns.tolist()
        
        # Garantir que a vari√°vel all_assets esteja dispon√≠vel em todas as tabs
        st.session_state['all_assets'] = all_assets
        
        # Importar fun√ß√µes auxiliares do m√≥dulo pair_trading_helpers
        from pair_trading_helpers import (
            find_cointegrated_pairs_tab, 
            detailed_analysis_tab, 
            trading_signals_tab, 
            backtest_tab, 
            optimization_tab, 
            tutorial_tab
        )
        
        # Tab 1: Identificar Pares
        with pair_tabs[0]:
            find_cointegrated_pairs_tab(pair_analyzer, all_assets, params)
          # Tab 2: An√°lise Detalhada
        with pair_tabs[1]:
            asset1, asset2 = detailed_analysis_tab(pair_analyzer, all_assets, params)
        
        # Tab 3: Sinais de Trading
        with pair_tabs[2]:
            # Verificar se asset1 e asset2 est√£o definidos
            if 'asset1' not in locals() or 'asset2' not in locals() or asset1 is None or asset2 is None:
                if len(all_assets) >= 2:
                    asset1 = all_assets[0]
                    asset2 = all_assets[1]
                else:
                    st.error("‚ùå N√£o foi poss√≠vel selecionar dois ativos. Selecione ativos manualmente na aba 'An√°lise Detalhada'.")
                    asset1, asset2 = None, None
            
            if asset1 and asset2:
                trading_signals_tab(pair_analyzer, asset1, asset2, params)
          # Tab 4: Backtest
        with pair_tabs[3]:
            if asset1 and asset2:
                backtest_tab(pair_analyzer, asset1, asset2, params, pair_analyzer.price_data)
        
        # Tab 5: Otimiza√ß√£o
        with pair_tabs[4]:
            if asset1 and asset2:
                optimization_tab(pair_analyzer, asset1, asset2, params)
          # Tab 6: Tutorial
        with pair_tabs[5]:
            tutorial_tab(all_assets)
            
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar dados: {str(e)}")

def show_statistical_analysis_page():
    """P√°gina de an√°lise estat√≠stica avan√ßada"""
    st.title(STATISTICAL_ANALYSIS_TITLE)
    
    RAW_DATA = get_raw_data_path()
    
    if not os.path.exists(RAW_DATA):
        st.error(DATA_NOT_FOUND_MSG)
        return
    
    try:
        df = pd.read_csv(RAW_DATA, index_col=0, parse_dates=True)
        
        # Header informativo usando helper
        from statistical_analysis_helpers import display_statistical_header
        display_statistical_header()
        
        # Inicializar an√°lise estat√≠stica
        stat_analyzer = StatisticalAnalysis(df)
          # Tabs principais
        stat_tabs = st.tabs([
            "üéØ An√°lise de Extremos", 
            "üìà Compara√ß√£o de Distribui√ß√µes", 
            "üî¨ Modelos de Risco",
            "üîÑ Pair Trading Avan√ßado",
            "üìö Documenta√ß√£o"
        ])
        
        # Tab 1: An√°lise de Extremos usando helper
        from statistical_analysis_helpers import extreme_analysis_tab
        with stat_tabs[0]:
            extreme_analysis_tab(stat_analyzer, df)
        
        # Tab 2: Compara√ß√£o de Distribui√ß√µes usando helper
        from statistical_analysis_helpers import distribution_comparison_tab
        with stat_tabs[1]:
            distribution_comparison_tab(stat_analyzer)
        
        # Tab 3: Modelos de Risco usando helper
        from statistical_analysis_helpers import risk_models_tab
        with stat_tabs[2]:
            risk_models_tab(stat_analyzer, df)
        
        # Tab 4: Pair Trading Avan√ßado usando helper
        from statistical_analysis_helpers import advanced_pair_trading_tab
        with stat_tabs[3]:
            advanced_pair_trading_tab(df)          # Tab 5: Documenta√ß√£o usando helper
        from statistical_analysis_helpers import documentation_tab
        with stat_tabs[4]:
            documentation_tab()
          # Adicionar bot√£o para download da an√°lise estat√≠stica em PDF
        st.sidebar.markdown("### üì• Download da An√°lise")
        st.sidebar.markdown("Baixe a an√°lise estat√≠stica completa em formato PDF")
        
        # Determinar qual ativo est√° selecionado atualmente - usando Session State
        if 'selected_asset_for_pdf' not in st.session_state:
            # Tentar obter um ativo dispon√≠vel da lista de colunas do dataframe
            if df is not None and not df.empty:
                assets_list = df.columns.tolist()
                if PETR4_SYMBOL in assets_list:
                    st.session_state['selected_asset_for_pdf'] = PETR4_SYMBOL
                elif len(assets_list) > 0:
                    st.session_state['selected_asset_for_pdf'] = assets_list[0]
                else:
                    st.session_state['selected_asset_for_pdf'] = "ATIVO"
            else:
                st.session_state['selected_asset_for_pdf'] = "ATIVO"
        
        # Permitir ao usu√°rio selecionar um ativo espec√≠fico para o PDF
        available_assets = [col for col in df.columns if df[col].dtype in ['float64', 'int64']] if not df.empty else []
        st.sidebar.selectbox("Ativo para o PDF:", available_assets, 
                            key="selected_asset_for_pdf",
                            index=0 if not available_assets or PETR4_SYMBOL not in available_assets else available_assets.index(PETR4_SYMBOL))
        
        if st.sidebar.button("üìÑ Download PDF da An√°lise Estat√≠stica", type="primary"):
            # C√≥digo para gerar o PDF completo com dados reais e visualiza√ß√µes
            with st.spinner("Gerando PDF da an√°lise estat√≠stica com gr√°ficos e dados..."):
                try:
                    import base64
                    from pdf_export_helpers import generate_complete_statistical_analysis_pdf
                    
                    # Usar o ativo selecionado do session_state
                    selected_asset = st.session_state.get('selected_asset_for_pdf')
                      # Gerar PDF com dados reais e visualiza√ß√µes
                    pdf_data = generate_complete_statistical_analysis_pdf(df, selected_asset)                    # Criar bot√£o de download usando a fun√ß√£o auxiliar
                    # Garantir que selected_asset √© string e n√£o √© None antes de usar replace()
                    if selected_asset is None:
                        file_suffix = 'geral'
                    else:
                        # Converter para string e substituir pontos por underscores
                        try:
                            file_suffix = str(selected_asset).replace('.', '_')
                        except:
                            file_suffix = 'geral'
                            
                    download_button_html = create_download_button(
                        pdf_data,
                        filename=f"analise_estatistica_{file_suffix}.pdf", 
                        button_text="Baixar An√°lise Estat√≠stica Completa (PDF)"
                    )
                    
                    st.sidebar.markdown(download_button_html, unsafe_allow_html=True)
                    st.sidebar.success("PDF gerado com sucesso! Clique no bot√£o acima para baixar.")
                except Exception as pdf_error:
                    st.sidebar.error(f"Erro ao gerar PDF: {pdf_error}")
    
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar dados: {str(e)}")

# =====================================================================
# FUN√á√ÉO PRINCIPAL E NAVEGA√á√ÉO
# =====================================================================

def main():
    """Fun√ß√£o principal da aplica√ß√£o"""
      # Sistema de navega√ß√£o por sidebar
    st.sidebar.title("üß≠ Navega√ß√£o")
    page = st.sidebar.selectbox(
        "Escolha a se√ß√£o:",
        [
            "üè† Home",
            "üìä Performance PCA", 
            "‚öñÔ∏è Compara√ß√£o MT5",
            "üí∞ Gest√£o por Setor",
            "üî¨ PCA Avan√ßado", 
            "üîÑ Pair Trading",
            "üìà An√°lise Estat√≠stica",
        ]
    )
    
    st.sidebar.markdown("---")
    
    # Carregar dados MT5 e armazenar no session_state
    mt5_data = load_mt5_data()
    if mt5_data:
        st.session_state['mt5_data'] = mt5_data
      # Roteamento das p√°ginas
    if page == "üè† Home":
        show_home_page()
    elif page == "üìä Performance PCA":
        show_pca_performance_page()
    elif page == "‚öñÔ∏è Compara√ß√£o MT5":
        show_mt5_comparison_page()
    elif page == "üí∞ Gest√£o por Setor":
        show_sector_management_page()
    elif page == "üî¨ PCA Avan√ßado":
        show_advanced_pca_page()
    elif page == "üîÑ Pair Trading":
        show_pair_trading_page()
    elif page == "üìà An√°lise Estat√≠stica":
        show_statistical_analysis_page()
    # elif page == "üìã Relat√≥rio Trading":
    #     show_trading_report_page()

# =====================================================================
# EXECU√á√ÉO DA APLICA√á√ÉO
# =====================================================================

if __name__ == "__main__":
    main()
